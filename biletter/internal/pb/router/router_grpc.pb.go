// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v5.29.2
// source: router.proto

package router

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	Router_RouteCEDData_FullMethodName           = "/router.Router/RouteCEDData"
	Router_GetResultInfo_FullMethodName          = "/router.Router/GetResultInfo"
	Router_GetRouterDetails_FullMethodName       = "/router.Router/GetRouterDetails"
	Router_RouteCreateUpdate_FullMethodName      = "/router.Router/RouteCreateUpdate"
	Router_UpdateListSettings_FullMethodName     = "/router.Router/UpdateListSettings"
	Router_GetAlerts_FullMethodName              = "/router.Router/GetAlerts"
	Router_AddParticipant_FullMethodName         = "/router.Router/AddParticipant"
	Router_ExpandParticipants_FullMethodName     = "/router.Router/ExpandParticipants"
	Router_ParticipantsUpdate_FullMethodName     = "/router.Router/ParticipantsUpdate"
	Router_StartProcess_FullMethodName           = "/router.Router/StartProcess"
	Router_StopProcess_FullMethodName            = "/router.Router/StopProcess"
	Router_GetAction_FullMethodName              = "/router.Router/GetAction"
	Router_Delegate_FullMethodName               = "/router.Router/Delegate"
	Router_Adjudication_FullMethodName           = "/router.Router/Adjudication"
	Router_StartAndSign_FullMethodName           = "/router.Router/StartAndSign"
	Router_GetStatusList_FullMethodName          = "/router.Router/GetStatusList"
	Router_GetPatternDetails_FullMethodName      = "/router.Router/GetPatternDetails"
	Router_DeleteRouterPattern_FullMethodName    = "/router.Router/DeleteRouterPattern"
	Router_StateData_FullMethodName              = "/router.Router/StateData"
	Router_OwnerReview_FullMethodName            = "/router.Router/OwnerReview"
	Router_ApproveCompletion_FullMethodName      = "/router.Router/ApproveCompletion"
	Router_GetActionData_FullMethodName          = "/router.Router/GetActionData"
	Router_MakingResolution_FullMethodName       = "/router.Router/MakingResolution"
	Router_ResolutionList_FullMethodName         = "/router.Router/ResolutionList"
	Router_AssignmentsRouteCreate_FullMethodName = "/router.Router/AssignmentsRouteCreate"
	Router_EDSCheck_FullMethodName               = "/router.Router/EDSCheck"
	Router_RouteFiles_FullMethodName             = "/router.Router/RouteFiles"
	Router_GetAllCmsId_FullMethodName            = "/router.Router/GetAllCmsId"
	Router_CmsDataUpdate_FullMethodName          = "/router.Router/CmsDataUpdate"
	Router_SignersData_FullMethodName            = "/router.Router/SignersData"
	Router_StageParticipants_FullMethodName      = "/router.Router/StageParticipants"
	Router_SimpleRouteCreate_FullMethodName      = "/router.Router/SimpleRouteCreate"
)

// RouterClient is the client API for Router service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RouterClient interface {
	RouteCEDData(ctx context.Context, in *RouteCEDDataRequest, opts ...grpc.CallOption) (*PatternDetailsResponseData, error)
	GetResultInfo(ctx context.Context, in *ResultRequest, opts ...grpc.CallOption) (*ResultResponse, error)
	GetRouterDetails(ctx context.Context, in *RouterDetailsRequest, opts ...grpc.CallOption) (*RouterDetailsResponse, error)
	RouteCreateUpdate(ctx context.Context, in *RouteCURequest, opts ...grpc.CallOption) (*StartProcessResponse, error)
	UpdateListSettings(ctx context.Context, in *RouteCURequest, opts ...grpc.CallOption) (*StartProcessResponse, error)
	GetAlerts(ctx context.Context, in *AlertsRequest, opts ...grpc.CallOption) (*AlertsResponse, error)
	AddParticipant(ctx context.Context, in *ParticipantRequest, opts ...grpc.CallOption) (*DelegateResponse, error)
	ExpandParticipants(ctx context.Context, in *ExpandParticipantsRequest, opts ...grpc.CallOption) (*DelegateResponse, error)
	ParticipantsUpdate(ctx context.Context, in *ParticipantsUpdateRequest, opts ...grpc.CallOption) (*ParticipantsUpdateResponse, error)
	StartProcess(ctx context.Context, in *StartProcessRequest, opts ...grpc.CallOption) (*StartProcessResponse, error)
	StopProcess(ctx context.Context, in *StopProcessRequest, opts ...grpc.CallOption) (*StopProcessResponse, error)
	GetAction(ctx context.Context, in *ActionListRequest, opts ...grpc.CallOption) (*ActionListResponse, error)
	Delegate(ctx context.Context, opts ...grpc.CallOption) (Router_DelegateClient, error)
	Adjudication(ctx context.Context, opts ...grpc.CallOption) (Router_AdjudicationClient, error)
	StartAndSign(ctx context.Context, opts ...grpc.CallOption) (Router_StartAndSignClient, error)
	GetStatusList(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*StatusListResponse, error)
	GetPatternDetails(ctx context.Context, in *PatternDetailsRequest, opts ...grpc.CallOption) (*PatternDetailsResponse, error)
	DeleteRouterPattern(ctx context.Context, in *AlertsRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	StateData(ctx context.Context, in *DetailStateRequest, opts ...grpc.CallOption) (*DetailStateResponse, error)
	OwnerReview(ctx context.Context, opts ...grpc.CallOption) (Router_OwnerReviewClient, error)
	ApproveCompletion(ctx context.Context, in *ApproveCompletionRequest, opts ...grpc.CallOption) (*AdjudicationResponse, error)
	GetActionData(ctx context.Context, in *AlertsRequest, opts ...grpc.CallOption) (*ActionDataResponse, error)
	MakingResolution(ctx context.Context, in *MakingResolutionRequest, opts ...grpc.CallOption) (*MakingResolutionResponse, error)
	ResolutionList(ctx context.Context, in *ResolutionListRequest, opts ...grpc.CallOption) (*ResolutionListResponse, error)
	AssignmentsRouteCreate(ctx context.Context, in *RouteCURequest, opts ...grpc.CallOption) (*StartProcessResponse, error)
	EDSCheck(ctx context.Context, in *EDSCheckRequest, opts ...grpc.CallOption) (*EDSCheckResponse, error)
	RouteFiles(ctx context.Context, in *RouteFilesRequest, opts ...grpc.CallOption) (*UploadedFiles, error)
	GetAllCmsId(ctx context.Context, in *CmsIdArrRequest, opts ...grpc.CallOption) (*CmsIdArr, error)
	CmsDataUpdate(ctx context.Context, in *CmsDataUpdateRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	SignersData(ctx context.Context, in *RouteCEDDataRequest, opts ...grpc.CallOption) (*SignersDataResponse, error)
	StageParticipants(ctx context.Context, in *StageParticipantsRequest, opts ...grpc.CallOption) (*StageParticipantsResponse, error)
	SimpleRouteCreate(ctx context.Context, in *SimpleRouteRequest, opts ...grpc.CallOption) (*CorrectStartProcessResponse, error)
}

type routerClient struct {
	cc grpc.ClientConnInterface
}

func NewRouterClient(cc grpc.ClientConnInterface) RouterClient {
	return &routerClient{cc}
}

func (c *routerClient) RouteCEDData(ctx context.Context, in *RouteCEDDataRequest, opts ...grpc.CallOption) (*PatternDetailsResponseData, error) {
	out := new(PatternDetailsResponseData)
	err := c.cc.Invoke(ctx, Router_RouteCEDData_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routerClient) GetResultInfo(ctx context.Context, in *ResultRequest, opts ...grpc.CallOption) (*ResultResponse, error) {
	out := new(ResultResponse)
	err := c.cc.Invoke(ctx, Router_GetResultInfo_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routerClient) GetRouterDetails(ctx context.Context, in *RouterDetailsRequest, opts ...grpc.CallOption) (*RouterDetailsResponse, error) {
	out := new(RouterDetailsResponse)
	err := c.cc.Invoke(ctx, Router_GetRouterDetails_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routerClient) RouteCreateUpdate(ctx context.Context, in *RouteCURequest, opts ...grpc.CallOption) (*StartProcessResponse, error) {
	out := new(StartProcessResponse)
	err := c.cc.Invoke(ctx, Router_RouteCreateUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routerClient) UpdateListSettings(ctx context.Context, in *RouteCURequest, opts ...grpc.CallOption) (*StartProcessResponse, error) {
	out := new(StartProcessResponse)
	err := c.cc.Invoke(ctx, Router_UpdateListSettings_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routerClient) GetAlerts(ctx context.Context, in *AlertsRequest, opts ...grpc.CallOption) (*AlertsResponse, error) {
	out := new(AlertsResponse)
	err := c.cc.Invoke(ctx, Router_GetAlerts_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routerClient) AddParticipant(ctx context.Context, in *ParticipantRequest, opts ...grpc.CallOption) (*DelegateResponse, error) {
	out := new(DelegateResponse)
	err := c.cc.Invoke(ctx, Router_AddParticipant_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routerClient) ExpandParticipants(ctx context.Context, in *ExpandParticipantsRequest, opts ...grpc.CallOption) (*DelegateResponse, error) {
	out := new(DelegateResponse)
	err := c.cc.Invoke(ctx, Router_ExpandParticipants_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routerClient) ParticipantsUpdate(ctx context.Context, in *ParticipantsUpdateRequest, opts ...grpc.CallOption) (*ParticipantsUpdateResponse, error) {
	out := new(ParticipantsUpdateResponse)
	err := c.cc.Invoke(ctx, Router_ParticipantsUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routerClient) StartProcess(ctx context.Context, in *StartProcessRequest, opts ...grpc.CallOption) (*StartProcessResponse, error) {
	out := new(StartProcessResponse)
	err := c.cc.Invoke(ctx, Router_StartProcess_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routerClient) StopProcess(ctx context.Context, in *StopProcessRequest, opts ...grpc.CallOption) (*StopProcessResponse, error) {
	out := new(StopProcessResponse)
	err := c.cc.Invoke(ctx, Router_StopProcess_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routerClient) GetAction(ctx context.Context, in *ActionListRequest, opts ...grpc.CallOption) (*ActionListResponse, error) {
	out := new(ActionListResponse)
	err := c.cc.Invoke(ctx, Router_GetAction_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routerClient) Delegate(ctx context.Context, opts ...grpc.CallOption) (Router_DelegateClient, error) {
	stream, err := c.cc.NewStream(ctx, &Router_ServiceDesc.Streams[0], Router_Delegate_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &routerDelegateClient{stream}
	return x, nil
}

type Router_DelegateClient interface {
	Send(*DelegationRequest) error
	CloseAndRecv() (*DelegateResponse, error)
	grpc.ClientStream
}

type routerDelegateClient struct {
	grpc.ClientStream
}

func (x *routerDelegateClient) Send(m *DelegationRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *routerDelegateClient) CloseAndRecv() (*DelegateResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(DelegateResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *routerClient) Adjudication(ctx context.Context, opts ...grpc.CallOption) (Router_AdjudicationClient, error) {
	stream, err := c.cc.NewStream(ctx, &Router_ServiceDesc.Streams[1], Router_Adjudication_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &routerAdjudicationClient{stream}
	return x, nil
}

type Router_AdjudicationClient interface {
	Send(*AdjudicationRequest) error
	CloseAndRecv() (*AdjudicationResponse, error)
	grpc.ClientStream
}

type routerAdjudicationClient struct {
	grpc.ClientStream
}

func (x *routerAdjudicationClient) Send(m *AdjudicationRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *routerAdjudicationClient) CloseAndRecv() (*AdjudicationResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(AdjudicationResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *routerClient) StartAndSign(ctx context.Context, opts ...grpc.CallOption) (Router_StartAndSignClient, error) {
	stream, err := c.cc.NewStream(ctx, &Router_ServiceDesc.Streams[2], Router_StartAndSign_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &routerStartAndSignClient{stream}
	return x, nil
}

type Router_StartAndSignClient interface {
	Send(*AdjudicationRequest) error
	CloseAndRecv() (*AdjudicationResponse, error)
	grpc.ClientStream
}

type routerStartAndSignClient struct {
	grpc.ClientStream
}

func (x *routerStartAndSignClient) Send(m *AdjudicationRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *routerStartAndSignClient) CloseAndRecv() (*AdjudicationResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(AdjudicationResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *routerClient) GetStatusList(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*StatusListResponse, error) {
	out := new(StatusListResponse)
	err := c.cc.Invoke(ctx, Router_GetStatusList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routerClient) GetPatternDetails(ctx context.Context, in *PatternDetailsRequest, opts ...grpc.CallOption) (*PatternDetailsResponse, error) {
	out := new(PatternDetailsResponse)
	err := c.cc.Invoke(ctx, Router_GetPatternDetails_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routerClient) DeleteRouterPattern(ctx context.Context, in *AlertsRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Router_DeleteRouterPattern_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routerClient) StateData(ctx context.Context, in *DetailStateRequest, opts ...grpc.CallOption) (*DetailStateResponse, error) {
	out := new(DetailStateResponse)
	err := c.cc.Invoke(ctx, Router_StateData_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routerClient) OwnerReview(ctx context.Context, opts ...grpc.CallOption) (Router_OwnerReviewClient, error) {
	stream, err := c.cc.NewStream(ctx, &Router_ServiceDesc.Streams[3], Router_OwnerReview_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &routerOwnerReviewClient{stream}
	return x, nil
}

type Router_OwnerReviewClient interface {
	Send(*RevisionRequest) error
	CloseAndRecv() (*OwnerReviewResponse, error)
	grpc.ClientStream
}

type routerOwnerReviewClient struct {
	grpc.ClientStream
}

func (x *routerOwnerReviewClient) Send(m *RevisionRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *routerOwnerReviewClient) CloseAndRecv() (*OwnerReviewResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(OwnerReviewResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *routerClient) ApproveCompletion(ctx context.Context, in *ApproveCompletionRequest, opts ...grpc.CallOption) (*AdjudicationResponse, error) {
	out := new(AdjudicationResponse)
	err := c.cc.Invoke(ctx, Router_ApproveCompletion_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routerClient) GetActionData(ctx context.Context, in *AlertsRequest, opts ...grpc.CallOption) (*ActionDataResponse, error) {
	out := new(ActionDataResponse)
	err := c.cc.Invoke(ctx, Router_GetActionData_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routerClient) MakingResolution(ctx context.Context, in *MakingResolutionRequest, opts ...grpc.CallOption) (*MakingResolutionResponse, error) {
	out := new(MakingResolutionResponse)
	err := c.cc.Invoke(ctx, Router_MakingResolution_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routerClient) ResolutionList(ctx context.Context, in *ResolutionListRequest, opts ...grpc.CallOption) (*ResolutionListResponse, error) {
	out := new(ResolutionListResponse)
	err := c.cc.Invoke(ctx, Router_ResolutionList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routerClient) AssignmentsRouteCreate(ctx context.Context, in *RouteCURequest, opts ...grpc.CallOption) (*StartProcessResponse, error) {
	out := new(StartProcessResponse)
	err := c.cc.Invoke(ctx, Router_AssignmentsRouteCreate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routerClient) EDSCheck(ctx context.Context, in *EDSCheckRequest, opts ...grpc.CallOption) (*EDSCheckResponse, error) {
	out := new(EDSCheckResponse)
	err := c.cc.Invoke(ctx, Router_EDSCheck_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routerClient) RouteFiles(ctx context.Context, in *RouteFilesRequest, opts ...grpc.CallOption) (*UploadedFiles, error) {
	out := new(UploadedFiles)
	err := c.cc.Invoke(ctx, Router_RouteFiles_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routerClient) GetAllCmsId(ctx context.Context, in *CmsIdArrRequest, opts ...grpc.CallOption) (*CmsIdArr, error) {
	out := new(CmsIdArr)
	err := c.cc.Invoke(ctx, Router_GetAllCmsId_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routerClient) CmsDataUpdate(ctx context.Context, in *CmsDataUpdateRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Router_CmsDataUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routerClient) SignersData(ctx context.Context, in *RouteCEDDataRequest, opts ...grpc.CallOption) (*SignersDataResponse, error) {
	out := new(SignersDataResponse)
	err := c.cc.Invoke(ctx, Router_SignersData_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routerClient) StageParticipants(ctx context.Context, in *StageParticipantsRequest, opts ...grpc.CallOption) (*StageParticipantsResponse, error) {
	out := new(StageParticipantsResponse)
	err := c.cc.Invoke(ctx, Router_StageParticipants_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routerClient) SimpleRouteCreate(ctx context.Context, in *SimpleRouteRequest, opts ...grpc.CallOption) (*CorrectStartProcessResponse, error) {
	out := new(CorrectStartProcessResponse)
	err := c.cc.Invoke(ctx, Router_SimpleRouteCreate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RouterServer is the server API for Router service.
// All implementations must embed UnimplementedRouterServer
// for forward compatibility
type RouterServer interface {
	RouteCEDData(context.Context, *RouteCEDDataRequest) (*PatternDetailsResponseData, error)
	GetResultInfo(context.Context, *ResultRequest) (*ResultResponse, error)
	GetRouterDetails(context.Context, *RouterDetailsRequest) (*RouterDetailsResponse, error)
	RouteCreateUpdate(context.Context, *RouteCURequest) (*StartProcessResponse, error)
	UpdateListSettings(context.Context, *RouteCURequest) (*StartProcessResponse, error)
	GetAlerts(context.Context, *AlertsRequest) (*AlertsResponse, error)
	AddParticipant(context.Context, *ParticipantRequest) (*DelegateResponse, error)
	ExpandParticipants(context.Context, *ExpandParticipantsRequest) (*DelegateResponse, error)
	ParticipantsUpdate(context.Context, *ParticipantsUpdateRequest) (*ParticipantsUpdateResponse, error)
	StartProcess(context.Context, *StartProcessRequest) (*StartProcessResponse, error)
	StopProcess(context.Context, *StopProcessRequest) (*StopProcessResponse, error)
	GetAction(context.Context, *ActionListRequest) (*ActionListResponse, error)
	Delegate(Router_DelegateServer) error
	Adjudication(Router_AdjudicationServer) error
	StartAndSign(Router_StartAndSignServer) error
	GetStatusList(context.Context, *emptypb.Empty) (*StatusListResponse, error)
	GetPatternDetails(context.Context, *PatternDetailsRequest) (*PatternDetailsResponse, error)
	DeleteRouterPattern(context.Context, *AlertsRequest) (*emptypb.Empty, error)
	StateData(context.Context, *DetailStateRequest) (*DetailStateResponse, error)
	OwnerReview(Router_OwnerReviewServer) error
	ApproveCompletion(context.Context, *ApproveCompletionRequest) (*AdjudicationResponse, error)
	GetActionData(context.Context, *AlertsRequest) (*ActionDataResponse, error)
	MakingResolution(context.Context, *MakingResolutionRequest) (*MakingResolutionResponse, error)
	ResolutionList(context.Context, *ResolutionListRequest) (*ResolutionListResponse, error)
	AssignmentsRouteCreate(context.Context, *RouteCURequest) (*StartProcessResponse, error)
	EDSCheck(context.Context, *EDSCheckRequest) (*EDSCheckResponse, error)
	RouteFiles(context.Context, *RouteFilesRequest) (*UploadedFiles, error)
	GetAllCmsId(context.Context, *CmsIdArrRequest) (*CmsIdArr, error)
	CmsDataUpdate(context.Context, *CmsDataUpdateRequest) (*emptypb.Empty, error)
	SignersData(context.Context, *RouteCEDDataRequest) (*SignersDataResponse, error)
	StageParticipants(context.Context, *StageParticipantsRequest) (*StageParticipantsResponse, error)
	SimpleRouteCreate(context.Context, *SimpleRouteRequest) (*CorrectStartProcessResponse, error)
	mustEmbedUnimplementedRouterServer()
}

// UnimplementedRouterServer must be embedded to have forward compatible implementations.
type UnimplementedRouterServer struct {
}

func (UnimplementedRouterServer) RouteCEDData(context.Context, *RouteCEDDataRequest) (*PatternDetailsResponseData, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RouteCEDData not implemented")
}
func (UnimplementedRouterServer) GetResultInfo(context.Context, *ResultRequest) (*ResultResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetResultInfo not implemented")
}
func (UnimplementedRouterServer) GetRouterDetails(context.Context, *RouterDetailsRequest) (*RouterDetailsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRouterDetails not implemented")
}
func (UnimplementedRouterServer) RouteCreateUpdate(context.Context, *RouteCURequest) (*StartProcessResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RouteCreateUpdate not implemented")
}
func (UnimplementedRouterServer) UpdateListSettings(context.Context, *RouteCURequest) (*StartProcessResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateListSettings not implemented")
}
func (UnimplementedRouterServer) GetAlerts(context.Context, *AlertsRequest) (*AlertsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAlerts not implemented")
}
func (UnimplementedRouterServer) AddParticipant(context.Context, *ParticipantRequest) (*DelegateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddParticipant not implemented")
}
func (UnimplementedRouterServer) ExpandParticipants(context.Context, *ExpandParticipantsRequest) (*DelegateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExpandParticipants not implemented")
}
func (UnimplementedRouterServer) ParticipantsUpdate(context.Context, *ParticipantsUpdateRequest) (*ParticipantsUpdateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ParticipantsUpdate not implemented")
}
func (UnimplementedRouterServer) StartProcess(context.Context, *StartProcessRequest) (*StartProcessResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartProcess not implemented")
}
func (UnimplementedRouterServer) StopProcess(context.Context, *StopProcessRequest) (*StopProcessResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StopProcess not implemented")
}
func (UnimplementedRouterServer) GetAction(context.Context, *ActionListRequest) (*ActionListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAction not implemented")
}
func (UnimplementedRouterServer) Delegate(Router_DelegateServer) error {
	return status.Errorf(codes.Unimplemented, "method Delegate not implemented")
}
func (UnimplementedRouterServer) Adjudication(Router_AdjudicationServer) error {
	return status.Errorf(codes.Unimplemented, "method Adjudication not implemented")
}
func (UnimplementedRouterServer) StartAndSign(Router_StartAndSignServer) error {
	return status.Errorf(codes.Unimplemented, "method StartAndSign not implemented")
}
func (UnimplementedRouterServer) GetStatusList(context.Context, *emptypb.Empty) (*StatusListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetStatusList not implemented")
}
func (UnimplementedRouterServer) GetPatternDetails(context.Context, *PatternDetailsRequest) (*PatternDetailsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPatternDetails not implemented")
}
func (UnimplementedRouterServer) DeleteRouterPattern(context.Context, *AlertsRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteRouterPattern not implemented")
}
func (UnimplementedRouterServer) StateData(context.Context, *DetailStateRequest) (*DetailStateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StateData not implemented")
}
func (UnimplementedRouterServer) OwnerReview(Router_OwnerReviewServer) error {
	return status.Errorf(codes.Unimplemented, "method OwnerReview not implemented")
}
func (UnimplementedRouterServer) ApproveCompletion(context.Context, *ApproveCompletionRequest) (*AdjudicationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ApproveCompletion not implemented")
}
func (UnimplementedRouterServer) GetActionData(context.Context, *AlertsRequest) (*ActionDataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetActionData not implemented")
}
func (UnimplementedRouterServer) MakingResolution(context.Context, *MakingResolutionRequest) (*MakingResolutionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MakingResolution not implemented")
}
func (UnimplementedRouterServer) ResolutionList(context.Context, *ResolutionListRequest) (*ResolutionListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResolutionList not implemented")
}
func (UnimplementedRouterServer) AssignmentsRouteCreate(context.Context, *RouteCURequest) (*StartProcessResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AssignmentsRouteCreate not implemented")
}
func (UnimplementedRouterServer) EDSCheck(context.Context, *EDSCheckRequest) (*EDSCheckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EDSCheck not implemented")
}
func (UnimplementedRouterServer) RouteFiles(context.Context, *RouteFilesRequest) (*UploadedFiles, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RouteFiles not implemented")
}
func (UnimplementedRouterServer) GetAllCmsId(context.Context, *CmsIdArrRequest) (*CmsIdArr, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllCmsId not implemented")
}
func (UnimplementedRouterServer) CmsDataUpdate(context.Context, *CmsDataUpdateRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CmsDataUpdate not implemented")
}
func (UnimplementedRouterServer) SignersData(context.Context, *RouteCEDDataRequest) (*SignersDataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SignersData not implemented")
}
func (UnimplementedRouterServer) StageParticipants(context.Context, *StageParticipantsRequest) (*StageParticipantsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StageParticipants not implemented")
}
func (UnimplementedRouterServer) SimpleRouteCreate(context.Context, *SimpleRouteRequest) (*CorrectStartProcessResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SimpleRouteCreate not implemented")
}
func (UnimplementedRouterServer) mustEmbedUnimplementedRouterServer() {}

// UnsafeRouterServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RouterServer will
// result in compilation errors.
type UnsafeRouterServer interface {
	mustEmbedUnimplementedRouterServer()
}

func RegisterRouterServer(s grpc.ServiceRegistrar, srv RouterServer) {
	s.RegisterService(&Router_ServiceDesc, srv)
}

func _Router_RouteCEDData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RouteCEDDataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouterServer).RouteCEDData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Router_RouteCEDData_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouterServer).RouteCEDData(ctx, req.(*RouteCEDDataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Router_GetResultInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResultRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouterServer).GetResultInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Router_GetResultInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouterServer).GetResultInfo(ctx, req.(*ResultRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Router_GetRouterDetails_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RouterDetailsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouterServer).GetRouterDetails(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Router_GetRouterDetails_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouterServer).GetRouterDetails(ctx, req.(*RouterDetailsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Router_RouteCreateUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RouteCURequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouterServer).RouteCreateUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Router_RouteCreateUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouterServer).RouteCreateUpdate(ctx, req.(*RouteCURequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Router_UpdateListSettings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RouteCURequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouterServer).UpdateListSettings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Router_UpdateListSettings_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouterServer).UpdateListSettings(ctx, req.(*RouteCURequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Router_GetAlerts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AlertsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouterServer).GetAlerts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Router_GetAlerts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouterServer).GetAlerts(ctx, req.(*AlertsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Router_AddParticipant_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ParticipantRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouterServer).AddParticipant(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Router_AddParticipant_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouterServer).AddParticipant(ctx, req.(*ParticipantRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Router_ExpandParticipants_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExpandParticipantsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouterServer).ExpandParticipants(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Router_ExpandParticipants_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouterServer).ExpandParticipants(ctx, req.(*ExpandParticipantsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Router_ParticipantsUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ParticipantsUpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouterServer).ParticipantsUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Router_ParticipantsUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouterServer).ParticipantsUpdate(ctx, req.(*ParticipantsUpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Router_StartProcess_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartProcessRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouterServer).StartProcess(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Router_StartProcess_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouterServer).StartProcess(ctx, req.(*StartProcessRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Router_StopProcess_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopProcessRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouterServer).StopProcess(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Router_StopProcess_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouterServer).StopProcess(ctx, req.(*StopProcessRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Router_GetAction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ActionListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouterServer).GetAction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Router_GetAction_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouterServer).GetAction(ctx, req.(*ActionListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Router_Delegate_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(RouterServer).Delegate(&routerDelegateServer{stream})
}

type Router_DelegateServer interface {
	SendAndClose(*DelegateResponse) error
	Recv() (*DelegationRequest, error)
	grpc.ServerStream
}

type routerDelegateServer struct {
	grpc.ServerStream
}

func (x *routerDelegateServer) SendAndClose(m *DelegateResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *routerDelegateServer) Recv() (*DelegationRequest, error) {
	m := new(DelegationRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Router_Adjudication_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(RouterServer).Adjudication(&routerAdjudicationServer{stream})
}

type Router_AdjudicationServer interface {
	SendAndClose(*AdjudicationResponse) error
	Recv() (*AdjudicationRequest, error)
	grpc.ServerStream
}

type routerAdjudicationServer struct {
	grpc.ServerStream
}

func (x *routerAdjudicationServer) SendAndClose(m *AdjudicationResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *routerAdjudicationServer) Recv() (*AdjudicationRequest, error) {
	m := new(AdjudicationRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Router_StartAndSign_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(RouterServer).StartAndSign(&routerStartAndSignServer{stream})
}

type Router_StartAndSignServer interface {
	SendAndClose(*AdjudicationResponse) error
	Recv() (*AdjudicationRequest, error)
	grpc.ServerStream
}

type routerStartAndSignServer struct {
	grpc.ServerStream
}

func (x *routerStartAndSignServer) SendAndClose(m *AdjudicationResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *routerStartAndSignServer) Recv() (*AdjudicationRequest, error) {
	m := new(AdjudicationRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Router_GetStatusList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouterServer).GetStatusList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Router_GetStatusList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouterServer).GetStatusList(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Router_GetPatternDetails_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PatternDetailsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouterServer).GetPatternDetails(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Router_GetPatternDetails_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouterServer).GetPatternDetails(ctx, req.(*PatternDetailsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Router_DeleteRouterPattern_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AlertsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouterServer).DeleteRouterPattern(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Router_DeleteRouterPattern_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouterServer).DeleteRouterPattern(ctx, req.(*AlertsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Router_StateData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DetailStateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouterServer).StateData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Router_StateData_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouterServer).StateData(ctx, req.(*DetailStateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Router_OwnerReview_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(RouterServer).OwnerReview(&routerOwnerReviewServer{stream})
}

type Router_OwnerReviewServer interface {
	SendAndClose(*OwnerReviewResponse) error
	Recv() (*RevisionRequest, error)
	grpc.ServerStream
}

type routerOwnerReviewServer struct {
	grpc.ServerStream
}

func (x *routerOwnerReviewServer) SendAndClose(m *OwnerReviewResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *routerOwnerReviewServer) Recv() (*RevisionRequest, error) {
	m := new(RevisionRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Router_ApproveCompletion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApproveCompletionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouterServer).ApproveCompletion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Router_ApproveCompletion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouterServer).ApproveCompletion(ctx, req.(*ApproveCompletionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Router_GetActionData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AlertsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouterServer).GetActionData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Router_GetActionData_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouterServer).GetActionData(ctx, req.(*AlertsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Router_MakingResolution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MakingResolutionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouterServer).MakingResolution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Router_MakingResolution_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouterServer).MakingResolution(ctx, req.(*MakingResolutionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Router_ResolutionList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResolutionListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouterServer).ResolutionList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Router_ResolutionList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouterServer).ResolutionList(ctx, req.(*ResolutionListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Router_AssignmentsRouteCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RouteCURequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouterServer).AssignmentsRouteCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Router_AssignmentsRouteCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouterServer).AssignmentsRouteCreate(ctx, req.(*RouteCURequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Router_EDSCheck_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EDSCheckRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouterServer).EDSCheck(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Router_EDSCheck_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouterServer).EDSCheck(ctx, req.(*EDSCheckRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Router_RouteFiles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RouteFilesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouterServer).RouteFiles(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Router_RouteFiles_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouterServer).RouteFiles(ctx, req.(*RouteFilesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Router_GetAllCmsId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CmsIdArrRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouterServer).GetAllCmsId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Router_GetAllCmsId_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouterServer).GetAllCmsId(ctx, req.(*CmsIdArrRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Router_CmsDataUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CmsDataUpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouterServer).CmsDataUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Router_CmsDataUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouterServer).CmsDataUpdate(ctx, req.(*CmsDataUpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Router_SignersData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RouteCEDDataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouterServer).SignersData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Router_SignersData_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouterServer).SignersData(ctx, req.(*RouteCEDDataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Router_StageParticipants_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StageParticipantsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouterServer).StageParticipants(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Router_StageParticipants_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouterServer).StageParticipants(ctx, req.(*StageParticipantsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Router_SimpleRouteCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SimpleRouteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouterServer).SimpleRouteCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Router_SimpleRouteCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouterServer).SimpleRouteCreate(ctx, req.(*SimpleRouteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Router_ServiceDesc is the grpc.ServiceDesc for Router service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Router_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "router.Router",
	HandlerType: (*RouterServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RouteCEDData",
			Handler:    _Router_RouteCEDData_Handler,
		},
		{
			MethodName: "GetResultInfo",
			Handler:    _Router_GetResultInfo_Handler,
		},
		{
			MethodName: "GetRouterDetails",
			Handler:    _Router_GetRouterDetails_Handler,
		},
		{
			MethodName: "RouteCreateUpdate",
			Handler:    _Router_RouteCreateUpdate_Handler,
		},
		{
			MethodName: "UpdateListSettings",
			Handler:    _Router_UpdateListSettings_Handler,
		},
		{
			MethodName: "GetAlerts",
			Handler:    _Router_GetAlerts_Handler,
		},
		{
			MethodName: "AddParticipant",
			Handler:    _Router_AddParticipant_Handler,
		},
		{
			MethodName: "ExpandParticipants",
			Handler:    _Router_ExpandParticipants_Handler,
		},
		{
			MethodName: "ParticipantsUpdate",
			Handler:    _Router_ParticipantsUpdate_Handler,
		},
		{
			MethodName: "StartProcess",
			Handler:    _Router_StartProcess_Handler,
		},
		{
			MethodName: "StopProcess",
			Handler:    _Router_StopProcess_Handler,
		},
		{
			MethodName: "GetAction",
			Handler:    _Router_GetAction_Handler,
		},
		{
			MethodName: "GetStatusList",
			Handler:    _Router_GetStatusList_Handler,
		},
		{
			MethodName: "GetPatternDetails",
			Handler:    _Router_GetPatternDetails_Handler,
		},
		{
			MethodName: "DeleteRouterPattern",
			Handler:    _Router_DeleteRouterPattern_Handler,
		},
		{
			MethodName: "StateData",
			Handler:    _Router_StateData_Handler,
		},
		{
			MethodName: "ApproveCompletion",
			Handler:    _Router_ApproveCompletion_Handler,
		},
		{
			MethodName: "GetActionData",
			Handler:    _Router_GetActionData_Handler,
		},
		{
			MethodName: "MakingResolution",
			Handler:    _Router_MakingResolution_Handler,
		},
		{
			MethodName: "ResolutionList",
			Handler:    _Router_ResolutionList_Handler,
		},
		{
			MethodName: "AssignmentsRouteCreate",
			Handler:    _Router_AssignmentsRouteCreate_Handler,
		},
		{
			MethodName: "EDSCheck",
			Handler:    _Router_EDSCheck_Handler,
		},
		{
			MethodName: "RouteFiles",
			Handler:    _Router_RouteFiles_Handler,
		},
		{
			MethodName: "GetAllCmsId",
			Handler:    _Router_GetAllCmsId_Handler,
		},
		{
			MethodName: "CmsDataUpdate",
			Handler:    _Router_CmsDataUpdate_Handler,
		},
		{
			MethodName: "SignersData",
			Handler:    _Router_SignersData_Handler,
		},
		{
			MethodName: "StageParticipants",
			Handler:    _Router_StageParticipants_Handler,
		},
		{
			MethodName: "SimpleRouteCreate",
			Handler:    _Router_SimpleRouteCreate_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Delegate",
			Handler:       _Router_Delegate_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "Adjudication",
			Handler:       _Router_Adjudication_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "StartAndSign",
			Handler:       _Router_StartAndSign_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "OwnerReview",
			Handler:       _Router_OwnerReview_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "router.proto",
}

const (
	Doc_RelatedDocData_FullMethodName             = "/router.Doc/RelatedDocData"
	Doc_SignByEgov_FullMethodName                 = "/router.Doc/SignByEgov"
	Doc_GetParticipantsData_FullMethodName        = "/router.Doc/GetParticipantsData"
	Doc_GetParticipantsFromDocCard_FullMethodName = "/router.Doc/GetParticipantsFromDocCard"
)

// DocClient is the client API for Doc service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DocClient interface {
	RelatedDocData(ctx context.Context, in *RelationRequest, opts ...grpc.CallOption) (*RelationResponse, error)
	SignByEgov(ctx context.Context, in *SignByEgovRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	GetParticipantsData(ctx context.Context, in *ResponsibleData, opts ...grpc.CallOption) (*ResponsibleData, error)
	GetParticipantsFromDocCard(ctx context.Context, in *ParticipantsFromDocCardRequest, opts ...grpc.CallOption) (*ParticipantsFromDocCardResponse, error)
}

type docClient struct {
	cc grpc.ClientConnInterface
}

func NewDocClient(cc grpc.ClientConnInterface) DocClient {
	return &docClient{cc}
}

func (c *docClient) RelatedDocData(ctx context.Context, in *RelationRequest, opts ...grpc.CallOption) (*RelationResponse, error) {
	out := new(RelationResponse)
	err := c.cc.Invoke(ctx, Doc_RelatedDocData_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *docClient) SignByEgov(ctx context.Context, in *SignByEgovRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Doc_SignByEgov_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *docClient) GetParticipantsData(ctx context.Context, in *ResponsibleData, opts ...grpc.CallOption) (*ResponsibleData, error) {
	out := new(ResponsibleData)
	err := c.cc.Invoke(ctx, Doc_GetParticipantsData_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *docClient) GetParticipantsFromDocCard(ctx context.Context, in *ParticipantsFromDocCardRequest, opts ...grpc.CallOption) (*ParticipantsFromDocCardResponse, error) {
	out := new(ParticipantsFromDocCardResponse)
	err := c.cc.Invoke(ctx, Doc_GetParticipantsFromDocCard_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DocServer is the server API for Doc service.
// All implementations must embed UnimplementedDocServer
// for forward compatibility
type DocServer interface {
	RelatedDocData(context.Context, *RelationRequest) (*RelationResponse, error)
	SignByEgov(context.Context, *SignByEgovRequest) (*emptypb.Empty, error)
	GetParticipantsData(context.Context, *ResponsibleData) (*ResponsibleData, error)
	GetParticipantsFromDocCard(context.Context, *ParticipantsFromDocCardRequest) (*ParticipantsFromDocCardResponse, error)
	mustEmbedUnimplementedDocServer()
}

// UnimplementedDocServer must be embedded to have forward compatible implementations.
type UnimplementedDocServer struct {
}

func (UnimplementedDocServer) RelatedDocData(context.Context, *RelationRequest) (*RelationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RelatedDocData not implemented")
}
func (UnimplementedDocServer) SignByEgov(context.Context, *SignByEgovRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SignByEgov not implemented")
}
func (UnimplementedDocServer) GetParticipantsData(context.Context, *ResponsibleData) (*ResponsibleData, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetParticipantsData not implemented")
}
func (UnimplementedDocServer) GetParticipantsFromDocCard(context.Context, *ParticipantsFromDocCardRequest) (*ParticipantsFromDocCardResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetParticipantsFromDocCard not implemented")
}
func (UnimplementedDocServer) mustEmbedUnimplementedDocServer() {}

// UnsafeDocServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DocServer will
// result in compilation errors.
type UnsafeDocServer interface {
	mustEmbedUnimplementedDocServer()
}

func RegisterDocServer(s grpc.ServiceRegistrar, srv DocServer) {
	s.RegisterService(&Doc_ServiceDesc, srv)
}

func _Doc_RelatedDocData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RelationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DocServer).RelatedDocData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Doc_RelatedDocData_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DocServer).RelatedDocData(ctx, req.(*RelationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Doc_SignByEgov_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SignByEgovRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DocServer).SignByEgov(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Doc_SignByEgov_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DocServer).SignByEgov(ctx, req.(*SignByEgovRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Doc_GetParticipantsData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResponsibleData)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DocServer).GetParticipantsData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Doc_GetParticipantsData_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DocServer).GetParticipantsData(ctx, req.(*ResponsibleData))
	}
	return interceptor(ctx, in, info, handler)
}

func _Doc_GetParticipantsFromDocCard_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ParticipantsFromDocCardRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DocServer).GetParticipantsFromDocCard(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Doc_GetParticipantsFromDocCard_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DocServer).GetParticipantsFromDocCard(ctx, req.(*ParticipantsFromDocCardRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Doc_ServiceDesc is the grpc.ServiceDesc for Doc service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Doc_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "router.Doc",
	HandlerType: (*DocServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RelatedDocData",
			Handler:    _Doc_RelatedDocData_Handler,
		},
		{
			MethodName: "SignByEgov",
			Handler:    _Doc_SignByEgov_Handler,
		},
		{
			MethodName: "GetParticipantsData",
			Handler:    _Doc_GetParticipantsData_Handler,
		},
		{
			MethodName: "GetParticipantsFromDocCard",
			Handler:    _Doc_GetParticipantsFromDocCard_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "router.proto",
}

const (
	Task_RelatedTaskData_FullMethodName        = "/router.Task/RelatedTaskData"
	Task_ResolutionsAssignments_FullMethodName = "/router.Task/ResolutionsAssignments"
	Task_GetTaskNameByID_FullMethodName        = "/router.Task/GetTaskNameByID"
)

// TaskClient is the client API for Task service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TaskClient interface {
	RelatedTaskData(ctx context.Context, in *RelationRequest, opts ...grpc.CallOption) (*RelationResponse, error)
	ResolutionsAssignments(ctx context.Context, in *IdType, opts ...grpc.CallOption) (*ResolutionsAssignmentsResponse, error)
	GetTaskNameByID(ctx context.Context, in *GetTaskNameRequest, opts ...grpc.CallOption) (*GetTaskNameResponse, error)
}

type taskClient struct {
	cc grpc.ClientConnInterface
}

func NewTaskClient(cc grpc.ClientConnInterface) TaskClient {
	return &taskClient{cc}
}

func (c *taskClient) RelatedTaskData(ctx context.Context, in *RelationRequest, opts ...grpc.CallOption) (*RelationResponse, error) {
	out := new(RelationResponse)
	err := c.cc.Invoke(ctx, Task_RelatedTaskData_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskClient) ResolutionsAssignments(ctx context.Context, in *IdType, opts ...grpc.CallOption) (*ResolutionsAssignmentsResponse, error) {
	out := new(ResolutionsAssignmentsResponse)
	err := c.cc.Invoke(ctx, Task_ResolutionsAssignments_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskClient) GetTaskNameByID(ctx context.Context, in *GetTaskNameRequest, opts ...grpc.CallOption) (*GetTaskNameResponse, error) {
	out := new(GetTaskNameResponse)
	err := c.cc.Invoke(ctx, Task_GetTaskNameByID_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TaskServer is the server API for Task service.
// All implementations must embed UnimplementedTaskServer
// for forward compatibility
type TaskServer interface {
	RelatedTaskData(context.Context, *RelationRequest) (*RelationResponse, error)
	ResolutionsAssignments(context.Context, *IdType) (*ResolutionsAssignmentsResponse, error)
	GetTaskNameByID(context.Context, *GetTaskNameRequest) (*GetTaskNameResponse, error)
	mustEmbedUnimplementedTaskServer()
}

// UnimplementedTaskServer must be embedded to have forward compatible implementations.
type UnimplementedTaskServer struct {
}

func (UnimplementedTaskServer) RelatedTaskData(context.Context, *RelationRequest) (*RelationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RelatedTaskData not implemented")
}
func (UnimplementedTaskServer) ResolutionsAssignments(context.Context, *IdType) (*ResolutionsAssignmentsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResolutionsAssignments not implemented")
}
func (UnimplementedTaskServer) GetTaskNameByID(context.Context, *GetTaskNameRequest) (*GetTaskNameResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTaskNameByID not implemented")
}
func (UnimplementedTaskServer) mustEmbedUnimplementedTaskServer() {}

// UnsafeTaskServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TaskServer will
// result in compilation errors.
type UnsafeTaskServer interface {
	mustEmbedUnimplementedTaskServer()
}

func RegisterTaskServer(s grpc.ServiceRegistrar, srv TaskServer) {
	s.RegisterService(&Task_ServiceDesc, srv)
}

func _Task_RelatedTaskData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RelationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskServer).RelatedTaskData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Task_RelatedTaskData_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskServer).RelatedTaskData(ctx, req.(*RelationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Task_ResolutionsAssignments_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IdType)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskServer).ResolutionsAssignments(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Task_ResolutionsAssignments_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskServer).ResolutionsAssignments(ctx, req.(*IdType))
	}
	return interceptor(ctx, in, info, handler)
}

func _Task_GetTaskNameByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTaskNameRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskServer).GetTaskNameByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Task_GetTaskNameByID_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskServer).GetTaskNameByID(ctx, req.(*GetTaskNameRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Task_ServiceDesc is the grpc.ServiceDesc for Task service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Task_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "router.Task",
	HandlerType: (*TaskServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RelatedTaskData",
			Handler:    _Task_RelatedTaskData_Handler,
		},
		{
			MethodName: "ResolutionsAssignments",
			Handler:    _Task_ResolutionsAssignments_Handler,
		},
		{
			MethodName: "GetTaskNameByID",
			Handler:    _Task_GetTaskNameByID_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "router.proto",
}

const ()

// IntegratorClient is the client API for Integrator service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type IntegratorClient interface {
}

type integratorClient struct {
	cc grpc.ClientConnInterface
}

func NewIntegratorClient(cc grpc.ClientConnInterface) IntegratorClient {
	return &integratorClient{cc}
}

// IntegratorServer is the server API for Integrator service.
// All implementations must embed UnimplementedIntegratorServer
// for forward compatibility
type IntegratorServer interface {
	mustEmbedUnimplementedIntegratorServer()
}

// UnimplementedIntegratorServer must be embedded to have forward compatible implementations.
type UnimplementedIntegratorServer struct {
}

func (UnimplementedIntegratorServer) mustEmbedUnimplementedIntegratorServer() {}

// UnsafeIntegratorServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to IntegratorServer will
// result in compilation errors.
type UnsafeIntegratorServer interface {
	mustEmbedUnimplementedIntegratorServer()
}

func RegisterIntegratorServer(s grpc.ServiceRegistrar, srv IntegratorServer) {
	s.RegisterService(&Integrator_ServiceDesc, srv)
}

// Integrator_ServiceDesc is the grpc.ServiceDesc for Integrator service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Integrator_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "router.Integrator",
	HandlerType: (*IntegratorServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams:     []grpc.StreamDesc{},
	Metadata:    "router.proto",
}

const (
	GatewayIntegration_EmploymentContract_FullMethodName         = "/router.GatewayIntegration/EmploymentContract"
	GatewayIntegration_SendSoapRequestByOperation_FullMethodName = "/router.GatewayIntegration/SendSoapRequestByOperation"
	GatewayIntegration_GetEnbekResponse_FullMethodName           = "/router.GatewayIntegration/GetEnbekResponse"
)

// GatewayIntegrationClient is the client API for GatewayIntegration service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type GatewayIntegrationClient interface {
	EmploymentContract(ctx context.Context, in *EmploymentContractRequest, opts ...grpc.CallOption) (*EmploymentContractResponse, error)
	SendSoapRequestByOperation(ctx context.Context, in *SignedXmlAndContextRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	GetEnbekResponse(ctx context.Context, in *ITC, opts ...grpc.CallOption) (*EnbekMessageResponse, error)
}

type gatewayIntegrationClient struct {
	cc grpc.ClientConnInterface
}

func NewGatewayIntegrationClient(cc grpc.ClientConnInterface) GatewayIntegrationClient {
	return &gatewayIntegrationClient{cc}
}

func (c *gatewayIntegrationClient) EmploymentContract(ctx context.Context, in *EmploymentContractRequest, opts ...grpc.CallOption) (*EmploymentContractResponse, error) {
	out := new(EmploymentContractResponse)
	err := c.cc.Invoke(ctx, GatewayIntegration_EmploymentContract_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayIntegrationClient) SendSoapRequestByOperation(ctx context.Context, in *SignedXmlAndContextRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, GatewayIntegration_SendSoapRequestByOperation_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayIntegrationClient) GetEnbekResponse(ctx context.Context, in *ITC, opts ...grpc.CallOption) (*EnbekMessageResponse, error) {
	out := new(EnbekMessageResponse)
	err := c.cc.Invoke(ctx, GatewayIntegration_GetEnbekResponse_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GatewayIntegrationServer is the server API for GatewayIntegration service.
// All implementations must embed UnimplementedGatewayIntegrationServer
// for forward compatibility
type GatewayIntegrationServer interface {
	EmploymentContract(context.Context, *EmploymentContractRequest) (*EmploymentContractResponse, error)
	SendSoapRequestByOperation(context.Context, *SignedXmlAndContextRequest) (*emptypb.Empty, error)
	GetEnbekResponse(context.Context, *ITC) (*EnbekMessageResponse, error)
	mustEmbedUnimplementedGatewayIntegrationServer()
}

// UnimplementedGatewayIntegrationServer must be embedded to have forward compatible implementations.
type UnimplementedGatewayIntegrationServer struct {
}

func (UnimplementedGatewayIntegrationServer) EmploymentContract(context.Context, *EmploymentContractRequest) (*EmploymentContractResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EmploymentContract not implemented")
}
func (UnimplementedGatewayIntegrationServer) SendSoapRequestByOperation(context.Context, *SignedXmlAndContextRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendSoapRequestByOperation not implemented")
}
func (UnimplementedGatewayIntegrationServer) GetEnbekResponse(context.Context, *ITC) (*EnbekMessageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetEnbekResponse not implemented")
}
func (UnimplementedGatewayIntegrationServer) mustEmbedUnimplementedGatewayIntegrationServer() {}

// UnsafeGatewayIntegrationServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to GatewayIntegrationServer will
// result in compilation errors.
type UnsafeGatewayIntegrationServer interface {
	mustEmbedUnimplementedGatewayIntegrationServer()
}

func RegisterGatewayIntegrationServer(s grpc.ServiceRegistrar, srv GatewayIntegrationServer) {
	s.RegisterService(&GatewayIntegration_ServiceDesc, srv)
}

func _GatewayIntegration_EmploymentContract_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmploymentContractRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayIntegrationServer).EmploymentContract(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GatewayIntegration_EmploymentContract_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayIntegrationServer).EmploymentContract(ctx, req.(*EmploymentContractRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GatewayIntegration_SendSoapRequestByOperation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SignedXmlAndContextRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayIntegrationServer).SendSoapRequestByOperation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GatewayIntegration_SendSoapRequestByOperation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayIntegrationServer).SendSoapRequestByOperation(ctx, req.(*SignedXmlAndContextRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GatewayIntegration_GetEnbekResponse_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ITC)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayIntegrationServer).GetEnbekResponse(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GatewayIntegration_GetEnbekResponse_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayIntegrationServer).GetEnbekResponse(ctx, req.(*ITC))
	}
	return interceptor(ctx, in, info, handler)
}

// GatewayIntegration_ServiceDesc is the grpc.ServiceDesc for GatewayIntegration service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var GatewayIntegration_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "router.GatewayIntegration",
	HandlerType: (*GatewayIntegrationServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "EmploymentContract",
			Handler:    _GatewayIntegration_EmploymentContract_Handler,
		},
		{
			MethodName: "SendSoapRequestByOperation",
			Handler:    _GatewayIntegration_SendSoapRequestByOperation_Handler,
		},
		{
			MethodName: "GetEnbekResponse",
			Handler:    _GatewayIntegration_GetEnbekResponse_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "router.proto",
}

const (
	FileStorage_GeneratePDF_FullMethodName                     = "/router.FileStorage/GeneratePDF"
	FileStorage_GenerateTaskReportByType_FullMethodName        = "/router.FileStorage/GenerateTaskReportByType"
	FileStorage_GenerateTaskReportByDept_FullMethodName        = "/router.FileStorage/GenerateTaskReportByDept"
	FileStorage_GenerateTaskReportByParticipant_FullMethodName = "/router.FileStorage/GenerateTaskReportByParticipant"
	FileStorage_FilesDelete_FullMethodName                     = "/router.FileStorage/FilesDelete"
	FileStorage_FilesAccess_FullMethodName                     = "/router.FileStorage/FilesAccess"
	FileStorage_UploadFiles_FullMethodName                     = "/router.FileStorage/UploadFiles"
	FileStorage_DownloadFile_FullMethodName                    = "/router.FileStorage/DownloadFile"
	FileStorage_GetPdfFile_FullMethodName                      = "/router.FileStorage/GetPdfFile"
	FileStorage_CopyFiles_FullMethodName                       = "/router.FileStorage/CopyFiles"
	FileStorage_GenerateDocReportByType_FullMethodName         = "/router.FileStorage/GenerateDocReportByType"
	FileStorage_GenerateDocReportByDept_FullMethodName         = "/router.FileStorage/GenerateDocReportByDept"
	FileStorage_GenerateDocReportByConf_FullMethodName         = "/router.FileStorage/GenerateDocReportByConf"
	FileStorage_GenerateDocReportByCategory_FullMethodName     = "/router.FileStorage/GenerateDocReportByCategory"
	FileStorage_GenerateDocReportByParticipant_FullMethodName  = "/router.FileStorage/GenerateDocReportByParticipant"
	FileStorage_CreateFolder_FullMethodName                    = "/router.FileStorage/CreateFolder"
	FileStorage_DeleteFolder_FullMethodName                    = "/router.FileStorage/DeleteFolder"
	FileStorage_CreateArchive_FullMethodName                   = "/router.FileStorage/CreateArchive"
)

// FileStorageClient is the client API for FileStorage service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type FileStorageClient interface {
	GeneratePDF(ctx context.Context, in *PdfGenerateRequest, opts ...grpc.CallOption) (*GeneratedPdfData, error)
	GenerateTaskReportByType(ctx context.Context, in *ListReportTaskByTypeData, opts ...grpc.CallOption) (*FileInfo, error)
	GenerateTaskReportByDept(ctx context.Context, in *ListReportTaskByDeptData, opts ...grpc.CallOption) (*FileInfo, error)
	GenerateTaskReportByParticipant(ctx context.Context, in *ListReportTaskByParticipantData, opts ...grpc.CallOption) (*FileInfo, error)
	FilesDelete(ctx context.Context, in *FilesDeleteRequest, opts ...grpc.CallOption) (*FilesDeleteResponse, error)
	FilesAccess(ctx context.Context, in *FilesAccessRequest, opts ...grpc.CallOption) (*FilesAccessResponse, error)
	UploadFiles(ctx context.Context, opts ...grpc.CallOption) (FileStorage_UploadFilesClient, error)
	DownloadFile(ctx context.Context, in *DownloadRequest, opts ...grpc.CallOption) (FileStorage_DownloadFileClient, error)
	GetPdfFile(ctx context.Context, in *GetPDFRequest, opts ...grpc.CallOption) (FileStorage_GetPdfFileClient, error)
	CopyFiles(ctx context.Context, in *CopyFilesRequest, opts ...grpc.CallOption) (*UploadedFiles, error)
	GenerateDocReportByType(ctx context.Context, in *ListReportDocByTypeData, opts ...grpc.CallOption) (*FileInfo, error)
	GenerateDocReportByDept(ctx context.Context, in *ListReportDocByDeptData, opts ...grpc.CallOption) (*FileInfo, error)
	GenerateDocReportByConf(ctx context.Context, in *ListReportDocByConfData, opts ...grpc.CallOption) (*FileInfo, error)
	GenerateDocReportByCategory(ctx context.Context, in *ListReportDocByCategoryData, opts ...grpc.CallOption) (*FileInfo, error)
	GenerateDocReportByParticipant(ctx context.Context, in *ListReportDocByParticipantData, opts ...grpc.CallOption) (*FileInfo, error)
	CreateFolder(ctx context.Context, in *CreateFolderRequest, opts ...grpc.CallOption) (*CreateFolderResponse, error)
	DeleteFolder(ctx context.Context, in *DeleteFolderRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	CreateArchive(ctx context.Context, in *CreateArchiveRequest, opts ...grpc.CallOption) (FileStorage_CreateArchiveClient, error)
}

type fileStorageClient struct {
	cc grpc.ClientConnInterface
}

func NewFileStorageClient(cc grpc.ClientConnInterface) FileStorageClient {
	return &fileStorageClient{cc}
}

func (c *fileStorageClient) GeneratePDF(ctx context.Context, in *PdfGenerateRequest, opts ...grpc.CallOption) (*GeneratedPdfData, error) {
	out := new(GeneratedPdfData)
	err := c.cc.Invoke(ctx, FileStorage_GeneratePDF_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileStorageClient) GenerateTaskReportByType(ctx context.Context, in *ListReportTaskByTypeData, opts ...grpc.CallOption) (*FileInfo, error) {
	out := new(FileInfo)
	err := c.cc.Invoke(ctx, FileStorage_GenerateTaskReportByType_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileStorageClient) GenerateTaskReportByDept(ctx context.Context, in *ListReportTaskByDeptData, opts ...grpc.CallOption) (*FileInfo, error) {
	out := new(FileInfo)
	err := c.cc.Invoke(ctx, FileStorage_GenerateTaskReportByDept_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileStorageClient) GenerateTaskReportByParticipant(ctx context.Context, in *ListReportTaskByParticipantData, opts ...grpc.CallOption) (*FileInfo, error) {
	out := new(FileInfo)
	err := c.cc.Invoke(ctx, FileStorage_GenerateTaskReportByParticipant_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileStorageClient) FilesDelete(ctx context.Context, in *FilesDeleteRequest, opts ...grpc.CallOption) (*FilesDeleteResponse, error) {
	out := new(FilesDeleteResponse)
	err := c.cc.Invoke(ctx, FileStorage_FilesDelete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileStorageClient) FilesAccess(ctx context.Context, in *FilesAccessRequest, opts ...grpc.CallOption) (*FilesAccessResponse, error) {
	out := new(FilesAccessResponse)
	err := c.cc.Invoke(ctx, FileStorage_FilesAccess_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileStorageClient) UploadFiles(ctx context.Context, opts ...grpc.CallOption) (FileStorage_UploadFilesClient, error) {
	stream, err := c.cc.NewStream(ctx, &FileStorage_ServiceDesc.Streams[0], FileStorage_UploadFiles_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &fileStorageUploadFilesClient{stream}
	return x, nil
}

type FileStorage_UploadFilesClient interface {
	Send(*UploadRequest) error
	CloseAndRecv() (*UploadResponse, error)
	grpc.ClientStream
}

type fileStorageUploadFilesClient struct {
	grpc.ClientStream
}

func (x *fileStorageUploadFilesClient) Send(m *UploadRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *fileStorageUploadFilesClient) CloseAndRecv() (*UploadResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(UploadResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *fileStorageClient) DownloadFile(ctx context.Context, in *DownloadRequest, opts ...grpc.CallOption) (FileStorage_DownloadFileClient, error) {
	stream, err := c.cc.NewStream(ctx, &FileStorage_ServiceDesc.Streams[1], FileStorage_DownloadFile_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &fileStorageDownloadFileClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type FileStorage_DownloadFileClient interface {
	Recv() (*Chunk, error)
	grpc.ClientStream
}

type fileStorageDownloadFileClient struct {
	grpc.ClientStream
}

func (x *fileStorageDownloadFileClient) Recv() (*Chunk, error) {
	m := new(Chunk)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *fileStorageClient) GetPdfFile(ctx context.Context, in *GetPDFRequest, opts ...grpc.CallOption) (FileStorage_GetPdfFileClient, error) {
	stream, err := c.cc.NewStream(ctx, &FileStorage_ServiceDesc.Streams[2], FileStorage_GetPdfFile_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &fileStorageGetPdfFileClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type FileStorage_GetPdfFileClient interface {
	Recv() (*Chunk, error)
	grpc.ClientStream
}

type fileStorageGetPdfFileClient struct {
	grpc.ClientStream
}

func (x *fileStorageGetPdfFileClient) Recv() (*Chunk, error) {
	m := new(Chunk)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *fileStorageClient) CopyFiles(ctx context.Context, in *CopyFilesRequest, opts ...grpc.CallOption) (*UploadedFiles, error) {
	out := new(UploadedFiles)
	err := c.cc.Invoke(ctx, FileStorage_CopyFiles_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileStorageClient) GenerateDocReportByType(ctx context.Context, in *ListReportDocByTypeData, opts ...grpc.CallOption) (*FileInfo, error) {
	out := new(FileInfo)
	err := c.cc.Invoke(ctx, FileStorage_GenerateDocReportByType_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileStorageClient) GenerateDocReportByDept(ctx context.Context, in *ListReportDocByDeptData, opts ...grpc.CallOption) (*FileInfo, error) {
	out := new(FileInfo)
	err := c.cc.Invoke(ctx, FileStorage_GenerateDocReportByDept_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileStorageClient) GenerateDocReportByConf(ctx context.Context, in *ListReportDocByConfData, opts ...grpc.CallOption) (*FileInfo, error) {
	out := new(FileInfo)
	err := c.cc.Invoke(ctx, FileStorage_GenerateDocReportByConf_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileStorageClient) GenerateDocReportByCategory(ctx context.Context, in *ListReportDocByCategoryData, opts ...grpc.CallOption) (*FileInfo, error) {
	out := new(FileInfo)
	err := c.cc.Invoke(ctx, FileStorage_GenerateDocReportByCategory_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileStorageClient) GenerateDocReportByParticipant(ctx context.Context, in *ListReportDocByParticipantData, opts ...grpc.CallOption) (*FileInfo, error) {
	out := new(FileInfo)
	err := c.cc.Invoke(ctx, FileStorage_GenerateDocReportByParticipant_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileStorageClient) CreateFolder(ctx context.Context, in *CreateFolderRequest, opts ...grpc.CallOption) (*CreateFolderResponse, error) {
	out := new(CreateFolderResponse)
	err := c.cc.Invoke(ctx, FileStorage_CreateFolder_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileStorageClient) DeleteFolder(ctx context.Context, in *DeleteFolderRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, FileStorage_DeleteFolder_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileStorageClient) CreateArchive(ctx context.Context, in *CreateArchiveRequest, opts ...grpc.CallOption) (FileStorage_CreateArchiveClient, error) {
	stream, err := c.cc.NewStream(ctx, &FileStorage_ServiceDesc.Streams[3], FileStorage_CreateArchive_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &fileStorageCreateArchiveClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type FileStorage_CreateArchiveClient interface {
	Recv() (*Chunk, error)
	grpc.ClientStream
}

type fileStorageCreateArchiveClient struct {
	grpc.ClientStream
}

func (x *fileStorageCreateArchiveClient) Recv() (*Chunk, error) {
	m := new(Chunk)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// FileStorageServer is the server API for FileStorage service.
// All implementations must embed UnimplementedFileStorageServer
// for forward compatibility
type FileStorageServer interface {
	GeneratePDF(context.Context, *PdfGenerateRequest) (*GeneratedPdfData, error)
	GenerateTaskReportByType(context.Context, *ListReportTaskByTypeData) (*FileInfo, error)
	GenerateTaskReportByDept(context.Context, *ListReportTaskByDeptData) (*FileInfo, error)
	GenerateTaskReportByParticipant(context.Context, *ListReportTaskByParticipantData) (*FileInfo, error)
	FilesDelete(context.Context, *FilesDeleteRequest) (*FilesDeleteResponse, error)
	FilesAccess(context.Context, *FilesAccessRequest) (*FilesAccessResponse, error)
	UploadFiles(FileStorage_UploadFilesServer) error
	DownloadFile(*DownloadRequest, FileStorage_DownloadFileServer) error
	GetPdfFile(*GetPDFRequest, FileStorage_GetPdfFileServer) error
	CopyFiles(context.Context, *CopyFilesRequest) (*UploadedFiles, error)
	GenerateDocReportByType(context.Context, *ListReportDocByTypeData) (*FileInfo, error)
	GenerateDocReportByDept(context.Context, *ListReportDocByDeptData) (*FileInfo, error)
	GenerateDocReportByConf(context.Context, *ListReportDocByConfData) (*FileInfo, error)
	GenerateDocReportByCategory(context.Context, *ListReportDocByCategoryData) (*FileInfo, error)
	GenerateDocReportByParticipant(context.Context, *ListReportDocByParticipantData) (*FileInfo, error)
	CreateFolder(context.Context, *CreateFolderRequest) (*CreateFolderResponse, error)
	DeleteFolder(context.Context, *DeleteFolderRequest) (*emptypb.Empty, error)
	CreateArchive(*CreateArchiveRequest, FileStorage_CreateArchiveServer) error
	mustEmbedUnimplementedFileStorageServer()
}

// UnimplementedFileStorageServer must be embedded to have forward compatible implementations.
type UnimplementedFileStorageServer struct {
}

func (UnimplementedFileStorageServer) GeneratePDF(context.Context, *PdfGenerateRequest) (*GeneratedPdfData, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GeneratePDF not implemented")
}
func (UnimplementedFileStorageServer) GenerateTaskReportByType(context.Context, *ListReportTaskByTypeData) (*FileInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateTaskReportByType not implemented")
}
func (UnimplementedFileStorageServer) GenerateTaskReportByDept(context.Context, *ListReportTaskByDeptData) (*FileInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateTaskReportByDept not implemented")
}
func (UnimplementedFileStorageServer) GenerateTaskReportByParticipant(context.Context, *ListReportTaskByParticipantData) (*FileInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateTaskReportByParticipant not implemented")
}
func (UnimplementedFileStorageServer) FilesDelete(context.Context, *FilesDeleteRequest) (*FilesDeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FilesDelete not implemented")
}
func (UnimplementedFileStorageServer) FilesAccess(context.Context, *FilesAccessRequest) (*FilesAccessResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FilesAccess not implemented")
}
func (UnimplementedFileStorageServer) UploadFiles(FileStorage_UploadFilesServer) error {
	return status.Errorf(codes.Unimplemented, "method UploadFiles not implemented")
}
func (UnimplementedFileStorageServer) DownloadFile(*DownloadRequest, FileStorage_DownloadFileServer) error {
	return status.Errorf(codes.Unimplemented, "method DownloadFile not implemented")
}
func (UnimplementedFileStorageServer) GetPdfFile(*GetPDFRequest, FileStorage_GetPdfFileServer) error {
	return status.Errorf(codes.Unimplemented, "method GetPdfFile not implemented")
}
func (UnimplementedFileStorageServer) CopyFiles(context.Context, *CopyFilesRequest) (*UploadedFiles, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CopyFiles not implemented")
}
func (UnimplementedFileStorageServer) GenerateDocReportByType(context.Context, *ListReportDocByTypeData) (*FileInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateDocReportByType not implemented")
}
func (UnimplementedFileStorageServer) GenerateDocReportByDept(context.Context, *ListReportDocByDeptData) (*FileInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateDocReportByDept not implemented")
}
func (UnimplementedFileStorageServer) GenerateDocReportByConf(context.Context, *ListReportDocByConfData) (*FileInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateDocReportByConf not implemented")
}
func (UnimplementedFileStorageServer) GenerateDocReportByCategory(context.Context, *ListReportDocByCategoryData) (*FileInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateDocReportByCategory not implemented")
}
func (UnimplementedFileStorageServer) GenerateDocReportByParticipant(context.Context, *ListReportDocByParticipantData) (*FileInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateDocReportByParticipant not implemented")
}
func (UnimplementedFileStorageServer) CreateFolder(context.Context, *CreateFolderRequest) (*CreateFolderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateFolder not implemented")
}
func (UnimplementedFileStorageServer) DeleteFolder(context.Context, *DeleteFolderRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteFolder not implemented")
}
func (UnimplementedFileStorageServer) CreateArchive(*CreateArchiveRequest, FileStorage_CreateArchiveServer) error {
	return status.Errorf(codes.Unimplemented, "method CreateArchive not implemented")
}
func (UnimplementedFileStorageServer) mustEmbedUnimplementedFileStorageServer() {}

// UnsafeFileStorageServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to FileStorageServer will
// result in compilation errors.
type UnsafeFileStorageServer interface {
	mustEmbedUnimplementedFileStorageServer()
}

func RegisterFileStorageServer(s grpc.ServiceRegistrar, srv FileStorageServer) {
	s.RegisterService(&FileStorage_ServiceDesc, srv)
}

func _FileStorage_GeneratePDF_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PdfGenerateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileStorageServer).GeneratePDF(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FileStorage_GeneratePDF_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileStorageServer).GeneratePDF(ctx, req.(*PdfGenerateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileStorage_GenerateTaskReportByType_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListReportTaskByTypeData)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileStorageServer).GenerateTaskReportByType(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FileStorage_GenerateTaskReportByType_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileStorageServer).GenerateTaskReportByType(ctx, req.(*ListReportTaskByTypeData))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileStorage_GenerateTaskReportByDept_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListReportTaskByDeptData)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileStorageServer).GenerateTaskReportByDept(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FileStorage_GenerateTaskReportByDept_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileStorageServer).GenerateTaskReportByDept(ctx, req.(*ListReportTaskByDeptData))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileStorage_GenerateTaskReportByParticipant_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListReportTaskByParticipantData)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileStorageServer).GenerateTaskReportByParticipant(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FileStorage_GenerateTaskReportByParticipant_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileStorageServer).GenerateTaskReportByParticipant(ctx, req.(*ListReportTaskByParticipantData))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileStorage_FilesDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FilesDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileStorageServer).FilesDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FileStorage_FilesDelete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileStorageServer).FilesDelete(ctx, req.(*FilesDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileStorage_FilesAccess_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FilesAccessRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileStorageServer).FilesAccess(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FileStorage_FilesAccess_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileStorageServer).FilesAccess(ctx, req.(*FilesAccessRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileStorage_UploadFiles_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(FileStorageServer).UploadFiles(&fileStorageUploadFilesServer{stream})
}

type FileStorage_UploadFilesServer interface {
	SendAndClose(*UploadResponse) error
	Recv() (*UploadRequest, error)
	grpc.ServerStream
}

type fileStorageUploadFilesServer struct {
	grpc.ServerStream
}

func (x *fileStorageUploadFilesServer) SendAndClose(m *UploadResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *fileStorageUploadFilesServer) Recv() (*UploadRequest, error) {
	m := new(UploadRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _FileStorage_DownloadFile_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(DownloadRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(FileStorageServer).DownloadFile(m, &fileStorageDownloadFileServer{stream})
}

type FileStorage_DownloadFileServer interface {
	Send(*Chunk) error
	grpc.ServerStream
}

type fileStorageDownloadFileServer struct {
	grpc.ServerStream
}

func (x *fileStorageDownloadFileServer) Send(m *Chunk) error {
	return x.ServerStream.SendMsg(m)
}

func _FileStorage_GetPdfFile_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetPDFRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(FileStorageServer).GetPdfFile(m, &fileStorageGetPdfFileServer{stream})
}

type FileStorage_GetPdfFileServer interface {
	Send(*Chunk) error
	grpc.ServerStream
}

type fileStorageGetPdfFileServer struct {
	grpc.ServerStream
}

func (x *fileStorageGetPdfFileServer) Send(m *Chunk) error {
	return x.ServerStream.SendMsg(m)
}

func _FileStorage_CopyFiles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CopyFilesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileStorageServer).CopyFiles(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FileStorage_CopyFiles_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileStorageServer).CopyFiles(ctx, req.(*CopyFilesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileStorage_GenerateDocReportByType_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListReportDocByTypeData)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileStorageServer).GenerateDocReportByType(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FileStorage_GenerateDocReportByType_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileStorageServer).GenerateDocReportByType(ctx, req.(*ListReportDocByTypeData))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileStorage_GenerateDocReportByDept_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListReportDocByDeptData)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileStorageServer).GenerateDocReportByDept(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FileStorage_GenerateDocReportByDept_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileStorageServer).GenerateDocReportByDept(ctx, req.(*ListReportDocByDeptData))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileStorage_GenerateDocReportByConf_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListReportDocByConfData)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileStorageServer).GenerateDocReportByConf(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FileStorage_GenerateDocReportByConf_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileStorageServer).GenerateDocReportByConf(ctx, req.(*ListReportDocByConfData))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileStorage_GenerateDocReportByCategory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListReportDocByCategoryData)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileStorageServer).GenerateDocReportByCategory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FileStorage_GenerateDocReportByCategory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileStorageServer).GenerateDocReportByCategory(ctx, req.(*ListReportDocByCategoryData))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileStorage_GenerateDocReportByParticipant_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListReportDocByParticipantData)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileStorageServer).GenerateDocReportByParticipant(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FileStorage_GenerateDocReportByParticipant_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileStorageServer).GenerateDocReportByParticipant(ctx, req.(*ListReportDocByParticipantData))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileStorage_CreateFolder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateFolderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileStorageServer).CreateFolder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FileStorage_CreateFolder_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileStorageServer).CreateFolder(ctx, req.(*CreateFolderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileStorage_DeleteFolder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteFolderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileStorageServer).DeleteFolder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FileStorage_DeleteFolder_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileStorageServer).DeleteFolder(ctx, req.(*DeleteFolderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileStorage_CreateArchive_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(CreateArchiveRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(FileStorageServer).CreateArchive(m, &fileStorageCreateArchiveServer{stream})
}

type FileStorage_CreateArchiveServer interface {
	Send(*Chunk) error
	grpc.ServerStream
}

type fileStorageCreateArchiveServer struct {
	grpc.ServerStream
}

func (x *fileStorageCreateArchiveServer) Send(m *Chunk) error {
	return x.ServerStream.SendMsg(m)
}

// FileStorage_ServiceDesc is the grpc.ServiceDesc for FileStorage service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var FileStorage_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "router.FileStorage",
	HandlerType: (*FileStorageServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GeneratePDF",
			Handler:    _FileStorage_GeneratePDF_Handler,
		},
		{
			MethodName: "GenerateTaskReportByType",
			Handler:    _FileStorage_GenerateTaskReportByType_Handler,
		},
		{
			MethodName: "GenerateTaskReportByDept",
			Handler:    _FileStorage_GenerateTaskReportByDept_Handler,
		},
		{
			MethodName: "GenerateTaskReportByParticipant",
			Handler:    _FileStorage_GenerateTaskReportByParticipant_Handler,
		},
		{
			MethodName: "FilesDelete",
			Handler:    _FileStorage_FilesDelete_Handler,
		},
		{
			MethodName: "FilesAccess",
			Handler:    _FileStorage_FilesAccess_Handler,
		},
		{
			MethodName: "CopyFiles",
			Handler:    _FileStorage_CopyFiles_Handler,
		},
		{
			MethodName: "GenerateDocReportByType",
			Handler:    _FileStorage_GenerateDocReportByType_Handler,
		},
		{
			MethodName: "GenerateDocReportByDept",
			Handler:    _FileStorage_GenerateDocReportByDept_Handler,
		},
		{
			MethodName: "GenerateDocReportByConf",
			Handler:    _FileStorage_GenerateDocReportByConf_Handler,
		},
		{
			MethodName: "GenerateDocReportByCategory",
			Handler:    _FileStorage_GenerateDocReportByCategory_Handler,
		},
		{
			MethodName: "GenerateDocReportByParticipant",
			Handler:    _FileStorage_GenerateDocReportByParticipant_Handler,
		},
		{
			MethodName: "CreateFolder",
			Handler:    _FileStorage_CreateFolder_Handler,
		},
		{
			MethodName: "DeleteFolder",
			Handler:    _FileStorage_DeleteFolder_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "UploadFiles",
			Handler:       _FileStorage_UploadFiles_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "DownloadFile",
			Handler:       _FileStorage_DownloadFile_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetPdfFile",
			Handler:       _FileStorage_GetPdfFile_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "CreateArchive",
			Handler:       _FileStorage_CreateArchive_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "router.proto",
}
